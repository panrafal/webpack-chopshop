{"version":3,"file":"static/js/321.5e3bdae5.chunk.js","mappings":"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","sources":["analysis/worker/transferHandlers.ts","analysis/worker/GraphWorkerClient.ts","logic/useGraphState.ts","ui/open/OpenStatsPage.tsx","ui/WarningBar.tsx","App.tsx","logic/usePinnedState.ts","analysis/changes.ts","analysis/dependencies.ts","analysis/filters.ts"],"sourcesContent":["import { transferHandlers } from \"comlink\"\nimport { findKey, memoize } from \"lodash\"\nimport * as filters from \"../filters\"\n\nconst knownFilters = Object.values(filters).filter(\n  (f) => typeof f === \"function\"\n)\n\nexport const registerTransferHandlers = memoize(() => {\n  transferHandlers.set(\"FILTER\", {\n    canHandle: (v: any): v is Function => knownFilters.includes(v),\n    serialize: (filter) => [findKey(filters, (f) => filter === f), []],\n    deserialize: (name: any) =>\n      // @ts-expect-error\n      filters[name],\n  })\n})\n","import { proxy, Remote, wrap } from \"comlink\"\nimport throat from \"throat\"\nimport { Changes } from \"../changes\"\nimport { getFilterKey } from \"../dependencies\"\nimport { Graph } from \"../graph\"\nimport { OpenProgressFn, ParseOptions } from \"../open\"\nimport { AbortSignal, createParallelProcessor } from \"../parallel\"\nimport { GraphWorkerBackend } from \"./GraphWorkerBackend\"\nimport { registerTransferHandlers } from \"./transferHandlers\"\n// import { GraphWorkerBackend } from \"./GraphWorkerBackend\"\n\nfunction getCacheKey(...args: any[]): string {\n  let key = \"\"\n  for (const arg of args) {\n    if (typeof arg === \"function\") {\n      key += getFilterKey(arg) + \":\"\n    } else if (typeof arg === \"object\" && arg && \"id\" in arg) {\n      key += arg.id + \":\"\n    } else {\n      key += JSON.stringify(arg) + \":\"\n    }\n  }\n  return key\n}\n\nfunction timeout(ms: number) {\n  return new Promise((_, reject) =>\n    setTimeout(() => reject(new AbortSignal(\"Timeout\")), ms)\n  )\n}\n\nexport class GraphWorkerClient\n  implements Omit<GraphWorkerBackend, \"applyChanges\">\n{\n  private worker!: Worker\n  private backend!: Remote<GraphWorkerBackend>\n  private cache: Record<string, any> = {}\n  private graph!: Graph\n  private throttled!: (fn: () => Promise<any>) => Promise<any>\n  constructor() {\n    registerTransferHandlers()\n    this.setupFreshBackend()\n  }\n\n  get currentGraph(): Graph | null {\n    return this.graph\n  }\n\n  private setupFreshBackend() {\n    if (this.worker) {\n      this.worker.terminate()\n    }\n    this.throttled = throat(100)\n    this.worker = new Worker(new URL(\"./GraphWorkerBackend\", import.meta.url))\n    this.backend = wrap<GraphWorkerBackend>(this.worker)\n  }\n\n  private implement<Prop extends keyof GraphWorkerBackend>(\n    prop: Prop\n  ): GraphWorkerBackend[Prop] {\n    return (...args: any) => {\n      const graph = this.graph\n      if (!graph) throw new Error(\"Graph is not set!\")\n      const cacheKey = `${graph.version}:${prop}:${getCacheKey(...args)}`\n      if (this.cache[cacheKey]) return this.cache[cacheKey]\n      const queueStart = performance.now()\n      const promise = this.throttled(async () => {\n        // don't make a call when aborted\n        if (graph.parallel.aborted) {\n          console.warn(\"ABORTING\", prop)\n          throw graph.parallel.aborted\n        }\n        const workStart = performance.now()\n        try {\n          return await Promise.race([\n            graph.parallel.abortSignal,\n            // timeout(15000),\n            this.backend[prop](...args),\n          ])\n        } finally {\n          console.log(\n            `[RPC] ${prop}: work: ${Math.round(\n              performance.now() - workStart\n            )}ms queue: ${Math.round(performance.now() - queueStart)}ms`\n          )\n        }\n      })\n\n      this.cache[cacheKey] = promise\n      return promise\n    }\n  }\n\n  async openGraph(\n    file: string | File,\n    options: ParseOptions,\n    reportProgress: OpenProgressFn\n  ): Promise<Graph> {\n    this.setupFreshBackend()\n    const graph = await this.backend.openGraph(\n      file,\n      options,\n      proxy(reportProgress)\n    )\n    this.graph = {\n      ...graph,\n      cache: {},\n      parallel: createParallelProcessor(),\n      revert: [],\n    }\n    return this.graph\n  }\n\n  setGraph(graph: Graph): any {\n    this.graph = graph\n    this.cache = {}\n    console.time(\"graph copy\")\n    const promise = this.backend.setGraph({\n      version: graph.version,\n      root: graph.root,\n      nodes: graph.nodes,\n      edges: graph.edges,\n      errors: [],\n    })\n    console.timeEnd(\"graph copy\")\n    return promise\n  }\n\n  async setGraphAndApplyChanges(graph: Graph, changes: Changes) {\n    this.graph = graph\n    this.cache = {}\n    return this.backend.applyChanges(changes)\n  }\n\n  calculateGroupSizes = this.implement(\"calculateGroupSizes\")\n  calculateTreeSizeRetainedByNode = this.implement(\n    \"calculateTreeSizeRetainedByNode\"\n  )\n  calculateTreeSizeRetainedByEdge = this.implement(\n    \"calculateTreeSizeRetainedByEdge\"\n  )\n  calculateTreeSize = this.implement(\"calculateTreeSize\")\n  findChains = this.implement(\"findChains\")\n  findNodeCycles = this.implement(\"findNodeCycles\")\n  getAsyncEdges = this.implement(\"getAsyncEdges\")\n  getDeepNodeChildren = this.implement(\"getDeepNodeChildren\")\n  getEnabledChildEdges = this.implement(\"getEnabledChildEdges\")\n  getEnabledParentEdges = this.implement(\"getEnabledParentEdges\")\n  getNodesRetainedByNode = this.implement(\"getNodesRetainedByNode\")\n  getNodesRetainedByEdge = this.implement(\"getNodesRetainedByEdge\")\n  getDeepNodeParents = this.implement(\"getDeepNodeParents\")\n}\n","import { useCallback, useEffect, useMemo, useState } from \"react\"\nimport {\n  applyChanges,\n  Changes,\n  hasChanges,\n  revertGraph,\n} from \"../analysis/changes\"\nimport { Graph, modifyGraph } from \"../analysis/graph\"\nimport { ParseOptions } from \"../analysis/open\"\nimport { GraphWorkerClient } from \"../analysis/worker/GraphWorkerClient\"\nimport { PromiseTrackerFn } from \"../ui/hooks/usePromiseTracker\"\nimport { useHistoryState } from \"./useHistoryState\"\n\nexport type ChangesReducerFn = (changes: Changes) => Changes\nexport type UpdateChangesFn = (reducer: ChangesReducerFn) => void\nexport type GraphLoadState =\n  | null\n  | { message: string; progress: number }\n  | Error\n\nconst appliedChanges = Symbol(\"appliedChanges\")\n\nfunction modifyLocalAndWorkerGraphs(\n  graph: Graph,\n  graphWorker: GraphWorkerClient,\n  changes: Changes,\n  setLocalGraph: (graph: Graph) => void\n) {\n  return modifyGraph(graph, (newGraph) => {\n    revertGraph(newGraph)\n    applyChanges(newGraph, changes)\n    // @ts-expect-error\n    newGraph[appliedChanges] = changes\n    graphWorker.setGraphAndApplyChanges(newGraph, changes)\n    setLocalGraph(newGraph)\n  })\n}\n\nexport function useGraphState({\n  trackLoading,\n  onLoaded,\n}: {\n  trackLoading: PromiseTrackerFn\n  onLoaded: () => void\n}) {\n  const [graphLoadState, setGraphLoadState] = useState<GraphLoadState>(null)\n  const [graph, setLocalGraph] = useState<Graph | undefined | null>()\n  const graphWorker = useMemo(() => new GraphWorkerClient(), [])\n\n  const [historyState, updateHistoryState] = useHistoryState()\n  const [changes, updateChanges] = useMemo(\n    () => [\n      historyState.changes,\n      (fn: ChangesReducerFn) =>\n        updateHistoryState((state) => ({\n          ...state,\n          changes: fn(state.changes),\n        })),\n    ],\n    [historyState, updateHistoryState]\n  )\n\n  const openGraph = useCallback(\n    async (\n      file: string | File,\n      options: Omit<ParseOptions, \"reportProgress\">\n    ) => {\n      const run = async () => {\n        try {\n          if (graph) graph.parallel.abort()\n          let lastProgressMessage: string\n          const reportProgress = (message: string, progress: number) => {\n            if (message !== lastProgressMessage || progress === 1) {\n              if (lastProgressMessage)\n                console.timeEnd(`[Open] ${lastProgressMessage}`)\n              if (progress !== 1) console.time(`[Open] ${message}`)\n              lastProgressMessage = message\n            }\n            console.log(message, progress)\n            setGraphLoadState(progress === 1 ? null : { message, progress })\n          }\n          reportProgress(\"initializing\", 0)\n          const newGraph = await graphWorker.openGraph(\n            file,\n            options,\n            reportProgress\n          )\n\n          reportProgress(\"applying changes\", 0.9)\n          modifyLocalAndWorkerGraphs(\n            newGraph,\n            graphWorker,\n            changes,\n            setLocalGraph\n          )\n\n          reportProgress(\"done\", 1)\n          onLoaded()\n        } catch (err: any) {\n          console.error(err)\n          setGraphLoadState(err)\n        }\n      }\n      trackLoading(run())\n    },\n    [trackLoading, graph, graphWorker, changes, onLoaded]\n  )\n\n  useEffect(() => {\n    if (!graph || (!hasChanges(changes) && graph.revert.length === 0)) return\n    // this effect is called from the last update\n    // @ts-expect-error\n    if (graph[appliedChanges] === changes) return\n    modifyLocalAndWorkerGraphs(graph, graphWorker, changes, setLocalGraph)\n  }, [graph, changes, graphWorker])\n\n  return {\n    graph,\n    graphWorker,\n    graphLoadState,\n    openGraph,\n    changes,\n    updateChanges,\n  }\n}\n","import {\n  Box,\n  Button,\n  FormControl,\n  FormControlLabel,\n  FormLabel,\n  LinearProgress,\n  Paper,\n  Radio,\n  RadioGroup,\n  Typography,\n} from \"@mui/material\"\nimport { useCallback, useEffect, useMemo, useState } from \"react\"\nimport { useDropzone } from \"react-dropzone\"\nimport { ParseOptions } from \"../../analysis/open\"\nimport { GraphLoadState } from \"../../logic/useGraphState\"\nimport ErrorBox from \"../ErrorBox\"\nimport { PromiseTrackerFn } from \"../hooks/usePromiseTracker\"\nimport { makeStyles } from \"../makeStyles\"\n\ntype Props = {\n  openGraph: (\n    file: string | File,\n    options: Omit<ParseOptions, \"reportProgress\">\n  ) => Promise<void>\n  trackLoading: PromiseTrackerFn\n  graphLoadState: GraphLoadState\n}\n\nconst useStyles = makeStyles({ name: \"OpenStatsPage\" })({\n  root: {\n    width: \"500px\",\n    display: \"flex\",\n    flexDirection: \"column\",\n    justifyContent: \"center\",\n    alignSelf: \"center\",\n    justifySelf: \"center\",\n    alignItems: \"center\",\n  },\n})\n\nlet initialGraphLoaded = false\n\nexport default function OpenStatsPage({\n  openGraph,\n  trackLoading,\n  graphLoadState,\n}: Props) {\n  const { classes, cx } = useStyles()\n  const [minifySources, setMinifySources] = useState<string>(\n    localStorage.getItem(\"minifySources\") || \"\"\n  )\n\n  const loading =\n    graphLoadState && \"progress\" in graphLoadState && graphLoadState\n  const error = !loading && graphLoadState\n\n  const parseOptions: ParseOptions = useMemo(\n    () => ({\n      minifySources:\n        minifySources === \"minify\"\n          ? true\n          : minifySources === \"gzip\"\n          ? \"gzip\"\n          : false,\n    }),\n    [minifySources]\n  )\n\n  const handleDrop = useCallback(\n    ([file], [rejected]) => {\n      if (rejected) {\n        trackLoading(\n          Promise.reject(\n            \"Only webpack build stats in json format are accepted!\"\n          )\n        )\n        return\n      }\n      openGraph(file, parseOptions)\n    },\n    [openGraph, trackLoading, parseOptions]\n  )\n\n  // Load stats from Cmd Line\n  useEffect(\n    () => {\n      if (process.env.REACT_APP_STATS && !initialGraphLoaded) {\n        initialGraphLoaded = true\n        openGraph(\n          process.env.PUBLIC_URL +\n            `/stats/${process.env.REACT_APP_STATS || \"\"}`,\n          parseOptions\n        )\n      }\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  )\n\n  const {\n    getRootProps,\n    getInputProps,\n    open: openFileDialog,\n  } = useDropzone({\n    multiple: false,\n    accept: \".json\",\n    onDrop: handleDrop,\n    noClick: true,\n    noKeyboard: true,\n    disabled: !!loading,\n  })\n\n  return (\n    <Box\n      onClick={() => openFileDialog()}\n      {...getRootProps({ className: cx(classes.root) })}\n    >\n      {loading ? (\n        <>\n          <LinearProgress\n            variant=\"determinate\"\n            value={loading.progress * 100}\n            sx={{ marginBottom: 1, width: \"100%\" }}\n          />\n          <Typography variant=\"body2\" color=\"text.secondary\">\n            {loading.message} {Math.round(loading.progress * 100)}%\n          </Typography>\n        </>\n      ) : (\n        <>\n          {error && <ErrorBox error={error} />}\n          {/* @ts-expect-error */}\n          <input {...getInputProps()} />\n          <Typography\n            variant=\"body1\"\n            sx={{ marginTop: 2, marginBottom: 2, textAlign: \"center\" }}\n          >\n            First, generate the stats file in webpack, then click below\n            <br />\n            or drop it anywhere on the page to start\n          </Typography>\n          <Button variant=\"contained\" onClick={() => openFileDialog()}>\n            Open stats file\n          </Button>\n          <Paper variant=\"outlined\" sx={{ marginTop: 4, padding: 2 }}>\n            <FormControl component=\"fieldset\">\n              <FormLabel component=\"legend\">Module sizes</FormLabel>\n              <RadioGroup\n                row\n                value={minifySources}\n                onChange={(e) => {\n                  const value = e.target.value as any\n                  setMinifySources(value)\n                  localStorage.setItem(\"minifySources\", value)\n                }}\n              >\n                <FormControlLabel\n                  value={\"\"}\n                  control={<Radio />}\n                  label=\"As-is\"\n                />\n                <FormControlLabel\n                  value={\"minify\"}\n                  control={<Radio />}\n                  label=\"Minified\"\n                />\n                <FormControlLabel\n                  value={\"gzip\"}\n                  control={<Radio />}\n                  label=\"GZipped\"\n                />\n              </RadioGroup>\n            </FormControl>\n          </Paper>\n        </>\n      )}\n    </Box>\n  )\n}\n","import WarningIcon from \"@mui/icons-material/Warning\"\nimport { amber as orange } from \"@mui/material/colors\"\nimport * as React from \"react\"\nimport { makeStyles } from \"./makeStyles\"\n\ntype Props = {\n  children: React.ReactNode\n}\n\nconst useStyles = makeStyles({ name: \"WarningBar\" })((theme) => ({\n  root: {\n    background: orange.A700,\n    padding: \"8px 24px 8px 24px\",\n    display: \"flex\",\n    alignItems: \"center\",\n    flexShrink: 0,\n    justifyContent: \"center\",\n    height: \"max-content\",\n  },\n  icon: {\n    marginRight: 8,\n  },\n}))\n\nexport default function WarningBar({ children }: Props) {\n  const { classes } = useStyles()\n\n  return (\n    <div className={classes.root}>\n      <WarningIcon className={classes.icon} />\n      <span>{children}</span>\n    </div>\n  )\n}\n","import {\n  AppBar,\n  Badge,\n  LinearProgress,\n  Tab,\n  Tabs,\n  Toolbar,\n  Typography,\n} from \"@mui/material\"\nimport { lazy, useState } from \"react\"\nimport { countVisibleChanges } from \"./analysis/changes\"\nimport { useGraphState } from \"./logic/useGraphState\"\nimport { usePinnedState } from \"./logic/usePinnedState\"\nimport { PromiseTrackerFn } from \"./ui/hooks/usePromiseTracker\"\nimport LoadingBoundary from \"./ui/LoadingBoundary\"\nimport { makeStyles } from \"./ui/makeStyles\"\nimport OpenStatsPage from \"./ui/open/OpenStatsPage\"\nimport WarningBar from \"./ui/WarningBar\"\n\nconst TreePage = lazy(() => import(\"./ui/tree/TreePage\"))\nconst ChangesPage = lazy(() => import(\"./ui/changes/ChangesPage\"))\n\nconst useStyles = makeStyles({ name: \"App\" })((theme) => ({\n  root: {\n    display: \"grid\",\n    gridAutoFlow: \"row\",\n    gridAutoRows: \"auto 1fr\",\n    height: \"100vh\",\n\n    // minWidth: 1200,\n    // flexDirection: \"column\",\n    // justifyContent: \"stretch\",\n  },\n  container: {\n    // maxWidth: 2000,\n    // minWidth: 1200,\n    width: \"100vw\",\n    marginLeft: \"auto\",\n    marginRight: \"auto\",\n  },\n  title: {\n    marginLeft: \"auto\",\n    textTransform: \"uppercase\",\n  },\n  search: {\n    color: \"#fff\",\n    borderBottom: \"2px solid #fff\",\n    width: 300,\n  },\n  dropzone: {},\n  openButton: {},\n  progress: {},\n  openFileMessage: {\n    textAlign: \"center\",\n    width: \"30em\",\n    alignSelf: \"center\",\n    margin: \"auto\",\n    cursor: \"pointer\",\n  },\n}))\n\ntype Props = {\n  className?: string\n  trackLoading: PromiseTrackerFn\n}\n\nexport default function App({ className, trackLoading }: Props) {\n  const { classes, cx } = useStyles()\n\n  const [page, setPage] = useState<string>(\"open\")\n\n  // Graph handling -----------------------------------\n\n  const {\n    graph,\n    graphWorker,\n    graphLoadState,\n    openGraph,\n    changes,\n    updateChanges,\n  } = useGraphState({\n    trackLoading,\n    onLoaded: () => setPage(\"tree/async\"),\n  })\n\n  // Pinned items ---------------------------------------\n  const [pinned, togglePinned] = usePinnedState()\n\n  // UI\n\n  let pageElement = null\n  if (!graph || page === \"open\") {\n    pageElement = (\n      <OpenStatsPage\n        openGraph={openGraph}\n        trackLoading={trackLoading}\n        graphLoadState={graphLoadState}\n      />\n    )\n  } else if (graph && page.startsWith(\"tree/\")) {\n    pageElement = (\n      <TreePage\n        className={classes.container}\n        graph={graph}\n        graphWorker={graphWorker}\n        pinned={pinned}\n        togglePinned={togglePinned}\n        updateChanges={updateChanges}\n        trackLoading={trackLoading}\n        mode={\n          page === \"tree/async\"\n            ? \"async\"\n            : page === \"tree/modules\"\n            ? \"modules\"\n            : page === \"tree/cycles\"\n            ? \"cycles\"\n            : \"modules\"\n        }\n      />\n    )\n  } else if (graph && page === \"changes\") {\n    pageElement = (\n      <ChangesPage\n        graph={graph}\n        changes={changes}\n        pinned={pinned}\n        updateChanges={updateChanges}\n      />\n    )\n  }\n\n  return (\n    <div className={cx(classes.root, className)}>\n      <AppBar position=\"static\" color=\"primary\">\n        <Toolbar className={classes.container} variant=\"dense\">\n          {\n            <Tabs\n              value={page}\n              indicatorColor=\"secondary\"\n              textColor=\"inherit\"\n              onChange={(event, v) => setPage(v)}\n            >\n              <Tab value=\"open\" label=\"Open stats\" />\n              <Tab disabled={!graph} value=\"tree/async\" label=\"Split points\" />\n              <Tab disabled={!graph} value=\"tree/modules\" label=\"Modules\" />\n              <Tab disabled={!graph} value=\"tree/cycles\" label=\"Cycles\" />\n              <Tab\n                disabled={!graph}\n                value=\"changes\"\n                label={\n                  <Badge\n                    badgeContent={countVisibleChanges(changes)}\n                    invisible={countVisibleChanges(changes) === 0}\n                    color=\"secondary\"\n                  >\n                    Show changes\n                  </Badge>\n                }\n              />\n            </Tabs>\n          }\n          <Typography variant=\"h6\" color=\"inherit\" className={classes.title}>\n            Webpack Chop Shop\n          </Typography>\n        </Toolbar>\n      </AppBar>\n      <LoadingBoundary\n        fallback={<LinearProgress className={classes.progress} />}\n      >\n        {pageElement}\n      </LoadingBoundary>\n      {graph && graph.errors.length > 0 && (\n        <WarningBar>\n          There where {graph.errors.length} errors found. Check the console for\n          more\n        </WarningBar>\n      )}\n    </div>\n  )\n}\n","import { useEffect, useReducer } from \"react\"\nimport { GraphNodeID } from \"../analysis/graph\"\n\ntype PinnedState = GraphNodeID[]\ntype TogglePinnedPayload = { id: GraphNodeID; set?: boolean } | GraphNodeID[]\nexport type TogglePinnedFn = (p: TogglePinnedPayload) => void\n\nexport function usePinnedState(): [\n  PinnedState,\n  (action: TogglePinnedPayload) => void\n] {\n  const [pinned, togglePinned] = useReducer(\n    (currentPinned: PinnedState, payload: TogglePinnedPayload): PinnedState => {\n      let newPinned\n      if (Array.isArray(payload)) {\n        newPinned = payload\n      } else {\n        const { id } = payload\n        const wasPinned = currentPinned.includes(id)\n        const isPinned = payload.set ?? !wasPinned\n        if (wasPinned === isPinned) return currentPinned\n        newPinned = isPinned\n          ? [id, ...currentPinned]\n          : currentPinned.filter((pin) => pin !== id)\n      }\n      window.localStorage.setItem(\"pinned\", JSON.stringify(newPinned))\n      return newPinned\n    },\n    []\n  )\n\n  useEffect(() => {\n    try {\n      togglePinned(JSON.parse(window.localStorage.getItem(\"pinned\") || \"[]\"))\n\n      const handleStorageEvent = (event: StorageEvent) => {\n        if (event.key === \"pinned\" && event.newValue) {\n          togglePinned(JSON.parse(event.newValue))\n        }\n      }\n\n      window.addEventListener(\"storage\", handleStorageEvent)\n\n      return () => {\n        window.removeEventListener(\"storage\", handleStorageEvent)\n      }\n    } catch (error) {\n      console.error(\"Local storage failed to initialize\", error)\n    }\n  }, [])\n\n  return [pinned, togglePinned]\n}\n","import { omit, omitBy } from \"lodash\"\nimport { Graph, GraphEdge, GraphEdgeID, resolveEdge, toggleEdge } from \"./graph\"\n\nexport type Changes = {\n  edgeToggles?: Record<GraphEdgeID, boolean>\n}\n\nexport const MOCKED_EDGE_KIND = \"mocked\"\n\nexport function hasChanges(changes: Changes): boolean {\n  return (\n    (changes.edgeToggles && Object.values(changes.edgeToggles).length > 0) ||\n    false\n  )\n}\n\nexport function countVisibleChanges(changes: Changes): number {\n  return changes.edgeToggles\n    ? Object.values(changes.edgeToggles).reduce(\n        (sum, enabled) => sum + (enabled ? 0 : 1),\n        0\n      )\n    : 0\n}\n\nexport function addEdgeToggleChange(\n  graph: Graph,\n  changes: Changes,\n  edge: GraphEdge,\n  enabled: boolean\n): Changes {\n  const wasOriginallyEnabled = edge\n    ? edge.kind !== MOCKED_EDGE_KIND && !edge.async\n    : false\n  // Add to queue only if it's a different state than originally\n  if (enabled !== wasOriginallyEnabled) {\n    return {\n      ...changes,\n      edgeToggles: { ...changes.edgeToggles, [edge.id]: enabled },\n    }\n  }\n  if (changes.edgeToggles && changes.edgeToggles[edge.id] != null) {\n    return { ...changes, edgeToggles: omit(changes.edgeToggles, [edge.id]) }\n  }\n  return changes\n}\n\nexport function resetEdgeToggles(changes: Changes, async: boolean): Changes {\n  return {\n    // async edges are enabled, sync edges are disabled - so we can just remove either one or the other\n    edgeToggles: omitBy(\n      changes.edgeToggles || {},\n      (enabled) => enabled === async\n    ),\n  }\n}\n\nexport function revertGraph(graph: Graph) {\n  for (const revert of graph.revert.reverse()) {\n    revert()\n  }\n  graph.revert.splice(0)\n}\n\nexport function applyChanges(graph: Graph, changes: Changes) {\n  for (const [edgeId, enabled] of Object.entries(changes.edgeToggles || {})) {\n    const edge = resolveEdge(graph, edgeId)\n    if (!edge) {\n      graph.errors.push({\n        message: `Edge ${edgeId} doesnt exist`,\n      })\n      continue\n    }\n    const prevEnabled = edge.enabled\n    graph.revert.push(() => {\n      toggleEdge(graph, edge, prevEnabled)\n    })\n    toggleEdge(graph, edge, enabled)\n  }\n}\n","import { difference } from \"lodash\"\nimport type {\n  Graph,\n  GraphEdge,\n  GraphEdgeID,\n  GraphNode,\n  GraphNodeID,\n} from \"./graph\"\nimport { getNode } from \"./graph\"\n\nconst filterKeys = new WeakMap()\nlet filterKeysCounter = 0\nexport function getFilterKey(f?: Function | null | undefined): string {\n  if (!f) return \"\"\n  if (!filterKeys.has(f)) {\n    filterKeys.set(f, `${f.name}${++filterKeysCounter}`)\n  }\n  return filterKeys.get(f)\n}\n\nexport const LAST_ITEM_IN_BRANCH = \"last\" as const\n\nasync function collectNodes(\n  graph: Graph,\n  node: GraphNode,\n  options: {\n    visited: {\n      [k in GraphNodeID]: GraphNode\n    }\n    direction: \"children\" | \"parents\"\n    filter?: (e: GraphEdge) => boolean | typeof LAST_ITEM_IN_BRANCH\n  }\n) {\n  const { direction, visited, filter } = options\n  visited[node.id] = node\n\n  for (const edge of node[direction]) {\n    if (visited[edge.toId]) continue\n    let included = filter ? filter(edge) : true\n    if (!included) continue\n    if (included === LAST_ITEM_IN_BRANCH) {\n      visited[node.id] = node\n      continue\n    }\n    await collectNodes(\n      graph,\n      direction === \"children\"\n        ? getNode(graph, edge.toId)\n        : getNode(graph, edge.fromId),\n      options\n    )\n    await graph.parallel.yield()\n  }\n}\n\nasync function collectEdges(\n  graph: Graph,\n  node: GraphNode,\n  options: {\n    visited: {\n      [k in GraphEdgeID]: GraphEdge\n    }\n    direction: \"children\" | \"parents\"\n    filter?: (e: GraphEdge) => boolean | typeof LAST_ITEM_IN_BRANCH\n  }\n) {\n  const { direction, visited, filter } = options\n\n  for (const edge of node[direction]) {\n    if (visited[edge.id]) continue\n    let included = filter ? filter(edge) : true\n    if (!included) continue\n    visited[edge.id] = edge\n    if (included === LAST_ITEM_IN_BRANCH) {\n      continue\n    }\n    await collectEdges(\n      graph,\n      direction === \"children\"\n        ? getNode(graph, edge.toId)\n        : getNode(graph, edge.fromId),\n      options\n    )\n    await graph.parallel.yield()\n  }\n}\n\nexport function getDeepNodeChildren(\n  graph: Graph,\n  node: GraphNode,\n  filter?: (e: GraphEdge) => boolean\n): Promise<ReadonlyArray<GraphNodeID>> {\n  const key = `getDeepNodeChildren:${node.id}:${getFilterKey(filter)}`\n  if (!graph.cache[key]) {\n    const visited: Record<string, GraphNode> = {}\n    graph.cache[key] = collectNodes(graph, node, {\n      visited,\n      direction: \"children\",\n      filter,\n    }).then(() => {\n      delete visited[node.id]\n      return Object.keys(visited)\n    })\n  }\n  return graph.cache[key]\n}\n\nexport function getDeepNodeParents(\n  graph: Graph,\n  node: GraphNode,\n  filter?: (e: GraphEdge) => boolean\n): Promise<ReadonlyArray<GraphNodeID>> {\n  const key = `getDeepNodeParents:${node.id}:${getFilterKey(filter)}`\n  if (!graph.cache[key]) {\n    const visited: Record<string, GraphNode> = {}\n    graph.cache[key] = collectNodes(graph, node, {\n      visited,\n      direction: \"parents\",\n      filter,\n    }).then(() => {\n      delete visited[node.id]\n      return Object.keys(visited)\n    })\n  }\n  return graph.cache[key]\n}\n\n// Returns all nodes introduced to the dependency tree of rootNode by adding the node to it.\n// In another word - how many modules are retained in the dependency tree because of the `node`\n// Does include the node itself\nexport function getNodesRetainedByNode(\n  graph: Graph,\n  rootNode: GraphNode,\n  node: GraphNode,\n  filter?: (e: GraphEdge) => boolean\n): Promise<ReadonlyArray<GraphNodeID>> {\n  const key = `getNodesRetainedByNode:${rootNode.id}:${node.id}:${getFilterKey(\n    filter\n  )}`\n  if (!graph.cache[key]) {\n    // Gather all children of the rootNode\n    const allChildrenPromise = getDeepNodeChildren(graph, rootNode, filter)\n\n    // Mark `node` as visited and gather children again - children of `node` will be ignored\n    // The difference between these two will show which nodes were included by the introduction of `node` to the tree\n    const visited = {\n      [node.id]: node,\n    }\n    const filteredChildrenPromise = collectNodes(graph, rootNode, {\n      visited,\n      direction: \"children\",\n      filter,\n    }).then(() => {\n      return Object.keys(visited)\n    })\n    graph.cache[key] = Promise.all([\n      allChildrenPromise,\n      filteredChildrenPromise,\n    ]).then(([allChildren, filteredChildren]) => {\n      // If they're not connected - there's no retention\n      if (allChildren.indexOf(node.id) < 0) {\n        return []\n      }\n      // Keep only children that were introduced by having the `node` in the tree\n      const ids = difference(allChildren, filteredChildren)\n      // + the node itself\n      if (allChildren.includes(node.id)) ids.push(node.id)\n      return ids\n    })\n  }\n  return graph.cache[key]\n}\n\n// Returns all nodes introduced to the dependency tree of rootNode by adding the edge to it.\n// In another word - how many modules are retained in the dependency tree because of the `edge`\n// Includes the node itself\nexport function getNodesRetainedByEdge(\n  graph: Graph,\n  rootNode: GraphNode,\n  edge: GraphEdge,\n  filter?: (e: GraphEdge) => boolean\n): Promise<ReadonlyArray<GraphNodeID>> {\n  const key = `getNodesRetainedByEdge:${rootNode.id}:${edge.id}:${getFilterKey(\n    filter\n  )}`\n  if (!edge.enabled) return Promise.resolve([])\n  if (!graph.cache[key]) {\n    // Gather all children of the rootNode\n    const allChildrenPromise = getDeepNodeChildren(graph, rootNode, filter)\n\n    // Gather children again, but with `edge` disabled\n    // The difference between these two will show which nodes were included by the introduction of `node` to the tree\n    const visited = {}\n    const filteredChildrenPromise = collectNodes(graph, rootNode, {\n      visited,\n      direction: \"children\",\n      filter: (e) => e.id !== edge.id && (!filter || filter(e)),\n    }).then(() => {\n      return Object.keys(visited)\n    })\n    graph.cache[key] = Promise.all([\n      allChildrenPromise,\n      filteredChildrenPromise,\n    ]).then(([allChildren, filteredChildren]) => {\n      // Keep only children that were introduced by having the `node` in the tree\n      const ids = difference(allChildren, filteredChildren)\n      return ids\n    })\n  }\n  return graph.cache[key]\n}\n\nexport function getEnabledChildEdges(\n  graph: Graph,\n  node: GraphNode\n): Promise<ReadonlyArray<GraphEdgeID>> {\n  const key = `getEnabledChildEdges:${node.id}`\n  if (!graph.cache[key]) {\n    const visited = {}\n    graph.cache[key] = collectEdges(graph, node, {\n      visited,\n      direction: \"children\",\n      filter: isEdgeEnabled,\n    }).then(() => {\n      return Object.keys(visited)\n    })\n  }\n  return graph.cache[key]\n}\n\nexport function getEnabledParentEdges(\n  graph: Graph,\n  node: GraphNode,\n  filter?: (e: GraphEdge) => boolean\n): Promise<ReadonlyArray<GraphEdgeID>> {\n  const key = `getEnabledParentEdges:${node.id}:${getFilterKey(filter)}`\n  if (!graph.cache[key]) {\n    const visited = {}\n    graph.cache[key] = collectEdges(graph, graph.root, {\n      visited,\n      direction: \"children\",\n      filter,\n    }).then(() => {\n      return node.parents\n        .filter((edge) => edge.enabled && edge.id in visited)\n        .map((edge) => edge.id)\n    })\n  }\n  return graph.cache[key]\n}\n\nexport function getAsyncEdges(\n  graph: Graph,\n  node: GraphNode,\n  filter?: (e: GraphEdge) => boolean | typeof LAST_ITEM_IN_BRANCH,\n  {\n    direction = \"children\",\n  }: {\n    direction?: \"children\" | \"parents\"\n  } = {}\n): Promise<ReadonlyArray<GraphEdgeID>> {\n  const key = `getAsyncEdges:${node.id}:${direction}:${getFilterKey(filter)}`\n  if (!graph.cache[key]) {\n    const visited: Record<GraphEdgeID, GraphEdge> = {}\n    graph.cache[key] = collectEdges(graph, node, {\n      visited,\n      direction,\n      filter,\n    }).then(() => {\n      return Object.values(visited)\n        .filter((e) => e.async)\n        .map((e) => e.id)\n    })\n  }\n  return graph.cache[key]\n}\n\nexport function keepOnlyEntryModules(\n  graph: Graph,\n  nodes: ReadonlyArray<GraphNode>\n) {\n  return nodes.filter((node: GraphNode) => {\n    if (node.kind !== \"module\") return false\n    return node.parents.every(\n      (edge) => getNode(graph, edge.fromId).kind !== \"module\"\n    )\n  })\n}\n\nexport function keepOnlyLeafModules(\n  graph: Graph,\n  nodes: ReadonlyArray<GraphNode>\n) {\n  return nodes.filter((node: GraphNode) => {\n    if (node.kind !== \"module\") return false\n    return node.children.length === 0\n  })\n}\n\nexport function isEdgeEnabled(edge: GraphEdge) {\n  return edge.enabled\n}\n","import { GraphEdge } from \"./graph\"\nimport { LAST_ITEM_IN_BRANCH } from \"./dependencies\"\n\nexport function currentGraphFilter(edge: GraphEdge) {\n  return edge.enabled\n}\n\nexport function baseGraphFilter(edge: GraphEdge) {\n  return !edge.async || edge.enabled\n}\n\nexport function stopOnAsyncModulesFilter(edge: GraphEdge) {\n  return edge.async ? LAST_ITEM_IN_BRANCH : true\n}\n\nexport function allAsyncAndEnabledFilter(edge: GraphEdge) {\n  return edge.async || edge.enabled\n}\n"],"names":["knownFilters","Object","values","filters","filter","f","registerTransferHandlers","memoize","transferHandlers","canHandle","v","includes","serialize","findKey","deserialize","name","GraphWorkerClient","constructor","worker","backend","cache","graph","throttled","calculateGroupSizes","this","implement","calculateTreeSizeRetainedByNode","calculateTreeSizeRetainedByEdge","calculateTreeSize","findChains","findNodeCycles","getAsyncEdges","getDeepNodeChildren","getEnabledChildEdges","getEnabledParentEdges","getNodesRetainedByNode","getNodesRetainedByEdge","getDeepNodeParents","setupFreshBackend","currentGraph","terminate","throat","Worker","URL","wrap","prop","args","Error","cacheKey","version","key","arg","getFilterKey","id","JSON","stringify","getCacheKey","queueStart","performance","now","promise","async","parallel","aborted","console","warn","workStart","Promise","race","abortSignal","log","Math","round","file","options","reportProgress","openGraph","proxy","createParallelProcessor","revert","setGraph","time","root","nodes","edges","errors","timeEnd","changes","applyChanges","appliedChanges","Symbol","modifyLocalAndWorkerGraphs","graphWorker","setLocalGraph","modifyGraph","newGraph","revertGraph","setGraphAndApplyChanges","useStyles","makeStyles","width","display","flexDirection","justifyContent","alignSelf","justifySelf","alignItems","initialGraphLoaded","OpenStatsPage","trackLoading","graphLoadState","classes","cx","minifySources","setMinifySources","useState","localStorage","getItem","loading","error","parseOptions","useMemo","handleDrop","useCallback","rejected","reject","useEffect","process","REACT_APP_STATS","getRootProps","getInputProps","open","openFileDialog","useDropzone","multiple","accept","onDrop","noClick","noKeyboard","disabled","Box","onClick","className","LinearProgress","variant","value","progress","sx","marginBottom","Typography","color","message","ErrorBox","marginTop","textAlign","Button","Paper","padding","FormControl","component","FormLabel","RadioGroup","row","onChange","e","target","setItem","FormControlLabel","control","Radio","label","theme","background","orange","flexShrink","height","icon","marginRight","WarningBar","children","Warning","TreePage","lazy","ChangesPage","gridAutoFlow","gridAutoRows","container","marginLeft","title","textTransform","search","borderBottom","dropzone","openButton","openFileMessage","margin","cursor","App","page","setPage","updateChanges","onLoaded","setGraphLoadState","historyState","updateHistoryState","useHistoryState","fn","state","lastProgressMessage","abort","err","run","hasChanges","length","useGraphState","pinned","togglePinned","useReducer","currentPinned","payload","newPinned","Array","isArray","wasPinned","isPinned","set","pin","window","parse","handleStorageEvent","event","newValue","addEventListener","removeEventListener","usePinnedState","pageElement","startsWith","mode","AppBar","position","Toolbar","Tabs","indicatorColor","textColor","Tab","Badge","badgeContent","countVisibleChanges","invisible","LoadingBoundary","fallback","edgeToggles","reduce","sum","enabled","addEdgeToggleChange","edge","kind","omit","resetEdgeToggles","omitBy","reverse","splice","edgeId","entries","resolveEdge","push","prevEnabled","toggleEdge","filterKeys","WeakMap","filterKeysCounter","has","get","LAST_ITEM_IN_BRANCH","currentGraphFilter","baseGraphFilter","stopOnAsyncModulesFilter","allAsyncAndEnabledFilter"],"sourceRoot":""}