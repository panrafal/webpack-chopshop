{"version":3,"file":"static/js/647.ff74b592.chunk.js","mappings":"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","sources":["analysis/parallel.ts","analysis/graph.ts","analysis/dependencies.ts","analysis/chains.ts","analysis/cycles.ts","analysis/info.ts","analysis/worker/SourceWorkerClient.ts","analysis/webpack.ts","analysis/open.ts","analysis/groups.ts","analysis/filters.ts","analysis/worker/transferHandlers.ts","analysis/worker/GraphWorkerBackend.ts","analysis/changes.ts","analysis/size.ts","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/global","../webpack/runtime/harmony module decorator","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/make namespace object","../webpack/runtime/node module decorator","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["export class AbortSignal {\n  message: string\n  constructor(message: string = \"Aborted\") {\n    this.message = message\n  }\n  toString() {\n    return this.message\n  }\n}\n\nexport function isAbortSignal(e: any) {\n  return e instanceof AbortSignal\n}\n\nexport const ABORTED = new AbortSignal()\n\nexport type ParallelProcessor = {\n  // allows to yield to micro or macro tasks (depends on how often it's called)\n  yield: () => Promise<void> | void\n  // abort processing of all tasks (next time they call yield() or use abortSignal)\n  abort: (err?: string | any) => void\n  // promise that will be rejected once abort() is called\n  abortSignal: Promise<void>\n  aborted: any\n}\n\n//\nexport const createParallelProcessor = ({\n  maxDelay = typeof window === \"undefined\" ? 100 : 16,\n}: { maxDelay?: number } = {}): ParallelProcessor => {\n  let abortSignalReject: (e: any) => void\n  let aborted: any\n  const abortSignal = new Promise<void>((_, reject) => {\n    abortSignalReject = reject\n  })\n\n  let lastYield = performance.now()\n\n  return {\n    yield() {\n      if (aborted) throw aborted\n      // yield to microtasks\n      if (performance.now() - lastYield < maxDelay) return\n      lastYield = performance.now()\n      // yield to macrotasks\n      return new Promise((resolve, reject) => {\n        abortSignal.catch((err) => reject(err))\n        setTimeout(resolve, 0)\n      })\n    },\n    abort(err) {\n      aborted = typeof err === \"string\" ? new AbortSignal(err) : err || ABORTED\n      abortSignalReject(aborted)\n    },\n    abortSignal,\n    get aborted() {\n      return aborted\n    },\n  }\n}\n","import { EdgeChain } from \"./chains\"\nimport {\n  AbortSignal,\n  ParallelProcessor,\n  createParallelProcessor,\n} from \"./parallel\"\n\nexport const ROOT_NODE_ID = \"root\"\nexport type GraphNodeID = string\nexport type GraphEdgeID = string\nexport type GraphElementID = string\nexport type NodeKind = string\nexport type EdgeKind = string\n\nexport type GraphEdgeSpec = {\n  name?: string\n  fromId: GraphNodeID\n  toId: GraphNodeID\n  kind: EdgeKind\n  async?: boolean\n  // IDs related to an async edge being loaded - eg. ID or asset of an async chunk\n  asyncIds?: string[]\n  enabled?: boolean\n  fromSource?: string\n  // Location in source code\n  fromLoc?: string\n  // Original source object\n  original?: any\n}\n\nexport type GraphEdge = GraphEdgeSpec & {\n  id: GraphEdgeID\n  enabled: boolean\n}\n\nexport type GraphNodeSpec = {\n  id: GraphNodeID\n  originalId: string\n  name?: string\n  kind: NodeKind\n  size: number\n  file?: string\n  exports?: string[]\n  usedExports?: string[]\n  source?: string\n  // Original source object\n  original?: any\n}\n\nexport type GraphNode = GraphNodeSpec & {\n  parents: Array<GraphEdge>\n  children: Array<GraphEdge>\n  treeSize?: number\n}\n\nexport type GraphElement = GraphNode | GraphEdge\n\nexport type Graph = {\n  version: number\n  root: GraphNode\n  nodes: {\n    [k in GraphNodeID]: GraphNode\n  }\n  edges: {\n    [k in GraphEdgeID]: GraphEdge\n  }\n  errors: Array<any>\n  cache: any\n  parallel: ParallelProcessor\n  revert: Array<() => void>\n}\n\nfunction createNode(_node: GraphNodeSpec): GraphNode {\n  return { parents: [], children: [], ..._node }\n}\n\nexport function createGraph(): Graph {\n  const root = createNode({\n    id: ROOT_NODE_ID,\n    originalId: ROOT_NODE_ID,\n    kind: \"compilation\",\n    size: 0,\n  })\n  const graph = {\n    version: 1,\n    root,\n    nodes: { [ROOT_NODE_ID]: root },\n    edges: {},\n    errors: [],\n    cache: {},\n    parallel: createParallelProcessor(),\n    revert: [],\n  }\n  return graph\n}\n\nexport function getNodeId(kind: string, id: string): GraphNodeID {\n  return `${kind}:${id}`\n}\nexport function getEdgeId(from: GraphNodeID, to: GraphNodeID): GraphEdgeID {\n  return `${from}->${to}`\n}\n\nexport function getNode(graph: Graph, id: GraphNodeID): GraphNode {\n  const node = graph.nodes[id]\n  if (!node) throw new Error(`Node ${id} not found`)\n  return node\n}\n\nexport function resolveNode(\n  graph: Graph,\n  id?: GraphNodeID | null\n): GraphNode | undefined | null {\n  if (!id) return null\n  return graph.nodes[id] || null\n}\n\nexport function getEdge(graph: Graph, id: GraphEdgeID): GraphEdge {\n  const edge = graph.edges[id]\n  if (!edge) throw new Error(`Edge ${id} not found`)\n  return edge\n}\n\nexport function resolveEdge(\n  graph: Graph,\n  id?: GraphEdgeID | null\n): GraphEdge | undefined | null {\n  if (!id) return null\n  return graph.edges[id] || null\n}\n\nexport function resolveEdgeForNodes(\n  graph: Graph,\n  from?: GraphNodeID | null,\n  to?: GraphNodeID | null\n): GraphEdge | undefined | null {\n  if (!from || !to) return null\n  return graph.edges[getEdgeId(from, to)]\n}\n\nexport function getNodes(\n  graph: Graph,\n  ids: ReadonlyArray<GraphNodeID>\n): ReadonlyArray<GraphNode> {\n  return ids.map(getNode.bind(null, graph))\n}\n\nexport function getAllNodes(graph: Graph): ReadonlyArray<GraphNode> {\n  return Object.values(graph.nodes) as any\n}\n\nexport function getEdges(\n  graph: Graph,\n  ids: ReadonlyArray<GraphEdgeID>\n): ReadonlyArray<GraphEdge> {\n  return ids.map(getEdge.bind(null, graph))\n}\n\nexport function getEdgesFromChain(\n  graph: Graph,\n  chain: EdgeChain\n): ReadonlyArray<GraphEdge> {\n  if (chain.length < 2) return []\n  const result = []\n  for (let i = 1; i < chain.length; ++i) {\n    result.push(getEdge(graph, getEdgeId(chain[i - 1], chain[i])))\n  }\n  return result\n}\n\nexport function addNode(graph: Graph, _node: GraphNodeSpec): GraphNode {\n  const node = createNode(_node)\n  if (graph.nodes[node.id]) throw new Error(`Node ${node.id} already in graph`)\n  graph.nodes[node.id] = node\n  return node\n}\n\nexport function addEdge(graph: Graph, _edge: GraphEdgeSpec): GraphEdge {\n  const id = getEdgeId(_edge.fromId, _edge.toId)\n  const edge = { enabled: true, id, ..._edge }\n  if (graph.edges[id]) {\n    return graph.edges[id]\n  }\n  graph.edges[id] = edge\n  graph.nodes[edge.fromId].children.push(edge)\n  graph.nodes[edge.toId].parents.push(edge)\n  return edge\n}\n\nexport function toggleEdge(graph: Graph, edge: GraphEdge, enabled: boolean) {\n  if (edge.enabled === enabled) return\n  edge.enabled = enabled\n}\n\nexport async function modifyGraph(\n  graph: Graph,\n  fn: (graph: Graph) => void | Promise<void>\n): Promise<Graph> {\n  const newGraph = {\n    ...graph,\n    version: graph.version + 1,\n    cache: {},\n    parallel: createParallelProcessor(),\n  }\n  await fn(newGraph)\n  // Abort the old graph computations only once the new one is set-up\n  // This allows the UI to switch to the new version before receiving abort messages\n  // workers should not modify the graph itself, they only interact with the graph's cache\n  // which is bound to the old `graph` object. So keeping them around should be safe.\n  await graph.parallel.abort(new AbortSignal(`Abort v${graph.version}`))\n  return newGraph\n}\n","import { difference } from \"lodash\"\nimport type {\n  Graph,\n  GraphEdge,\n  GraphEdgeID,\n  GraphNode,\n  GraphNodeID,\n} from \"./graph\"\nimport { getNode } from \"./graph\"\n\nconst filterKeys = new WeakMap()\nlet filterKeysCounter = 0\nexport function getFilterKey(f?: Function | null | undefined): string {\n  if (!f) return \"\"\n  if (!filterKeys.has(f)) {\n    filterKeys.set(f, `${f.name}${++filterKeysCounter}`)\n  }\n  return filterKeys.get(f)\n}\n\nexport const LAST_ITEM_IN_BRANCH = \"last\" as const\n\nasync function collectNodes(\n  graph: Graph,\n  node: GraphNode,\n  options: {\n    visited: {\n      [k in GraphNodeID]: GraphNode\n    }\n    direction: \"children\" | \"parents\"\n    filter?: (e: GraphEdge) => boolean | typeof LAST_ITEM_IN_BRANCH\n  }\n) {\n  const { direction, visited, filter } = options\n  visited[node.id] = node\n\n  for (const edge of node[direction]) {\n    if (visited[edge.toId]) continue\n    let included = filter ? filter(edge) : true\n    if (!included) continue\n    if (included === LAST_ITEM_IN_BRANCH) {\n      visited[node.id] = node\n      continue\n    }\n    await collectNodes(\n      graph,\n      direction === \"children\"\n        ? getNode(graph, edge.toId)\n        : getNode(graph, edge.fromId),\n      options\n    )\n    await graph.parallel.yield()\n  }\n}\n\nasync function collectEdges(\n  graph: Graph,\n  node: GraphNode,\n  options: {\n    visited: {\n      [k in GraphEdgeID]: GraphEdge\n    }\n    direction: \"children\" | \"parents\"\n    filter?: (e: GraphEdge) => boolean | typeof LAST_ITEM_IN_BRANCH\n  }\n) {\n  const { direction, visited, filter } = options\n\n  for (const edge of node[direction]) {\n    if (visited[edge.id]) continue\n    let included = filter ? filter(edge) : true\n    if (!included) continue\n    visited[edge.id] = edge\n    if (included === LAST_ITEM_IN_BRANCH) {\n      continue\n    }\n    await collectEdges(\n      graph,\n      direction === \"children\"\n        ? getNode(graph, edge.toId)\n        : getNode(graph, edge.fromId),\n      options\n    )\n    await graph.parallel.yield()\n  }\n}\n\nexport function getDeepNodeChildren(\n  graph: Graph,\n  node: GraphNode,\n  filter?: (e: GraphEdge) => boolean\n): Promise<ReadonlyArray<GraphNodeID>> {\n  const key = `getDeepNodeChildren:${node.id}:${getFilterKey(filter)}`\n  if (!graph.cache[key]) {\n    const visited: Record<string, GraphNode> = {}\n    graph.cache[key] = collectNodes(graph, node, {\n      visited,\n      direction: \"children\",\n      filter,\n    }).then(() => {\n      delete visited[node.id]\n      return Object.keys(visited)\n    })\n  }\n  return graph.cache[key]\n}\n\nexport function getDeepNodeParents(\n  graph: Graph,\n  node: GraphNode,\n  filter?: (e: GraphEdge) => boolean\n): Promise<ReadonlyArray<GraphNodeID>> {\n  const key = `getDeepNodeParents:${node.id}:${getFilterKey(filter)}`\n  if (!graph.cache[key]) {\n    const visited: Record<string, GraphNode> = {}\n    graph.cache[key] = collectNodes(graph, node, {\n      visited,\n      direction: \"parents\",\n      filter,\n    }).then(() => {\n      delete visited[node.id]\n      return Object.keys(visited)\n    })\n  }\n  return graph.cache[key]\n}\n\n// Returns all nodes introduced to the dependency tree of rootNode by adding the node to it.\n// In another word - how many modules are retained in the dependency tree because of the `node`\n// Does include the node itself\nexport function getNodesRetainedByNode(\n  graph: Graph,\n  rootNode: GraphNode,\n  node: GraphNode,\n  filter?: (e: GraphEdge) => boolean\n): Promise<ReadonlyArray<GraphNodeID>> {\n  const key = `getNodesRetainedByNode:${rootNode.id}:${node.id}:${getFilterKey(\n    filter\n  )}`\n  if (!graph.cache[key]) {\n    // Gather all children of the rootNode\n    const allChildrenPromise = getDeepNodeChildren(graph, rootNode, filter)\n\n    // Mark `node` as visited and gather children again - children of `node` will be ignored\n    // The difference between these two will show which nodes were included by the introduction of `node` to the tree\n    const visited = {\n      [node.id]: node,\n    }\n    const filteredChildrenPromise = collectNodes(graph, rootNode, {\n      visited,\n      direction: \"children\",\n      filter,\n    }).then(() => {\n      return Object.keys(visited)\n    })\n    graph.cache[key] = Promise.all([\n      allChildrenPromise,\n      filteredChildrenPromise,\n    ]).then(([allChildren, filteredChildren]) => {\n      // If they're not connected - there's no retention\n      if (allChildren.indexOf(node.id) < 0) {\n        return []\n      }\n      // Keep only children that were introduced by having the `node` in the tree\n      const ids = difference(allChildren, filteredChildren)\n      // + the node itself\n      if (allChildren.includes(node.id)) ids.push(node.id)\n      return ids\n    })\n  }\n  return graph.cache[key]\n}\n\n// Returns all nodes introduced to the dependency tree of rootNode by adding the edge to it.\n// In another word - how many modules are retained in the dependency tree because of the `edge`\n// Includes the node itself\nexport function getNodesRetainedByEdge(\n  graph: Graph,\n  rootNode: GraphNode,\n  edge: GraphEdge,\n  filter?: (e: GraphEdge) => boolean\n): Promise<ReadonlyArray<GraphNodeID>> {\n  const key = `getNodesRetainedByEdge:${rootNode.id}:${edge.id}:${getFilterKey(\n    filter\n  )}`\n  if (!edge.enabled) return Promise.resolve([])\n  if (!graph.cache[key]) {\n    // Gather all children of the rootNode\n    const allChildrenPromise = getDeepNodeChildren(graph, rootNode, filter)\n\n    // Gather children again, but with `edge` disabled\n    // The difference between these two will show which nodes were included by the introduction of `node` to the tree\n    const visited = {}\n    const filteredChildrenPromise = collectNodes(graph, rootNode, {\n      visited,\n      direction: \"children\",\n      filter: (e) => e.id !== edge.id && (!filter || filter(e)),\n    }).then(() => {\n      return Object.keys(visited)\n    })\n    graph.cache[key] = Promise.all([\n      allChildrenPromise,\n      filteredChildrenPromise,\n    ]).then(([allChildren, filteredChildren]) => {\n      // Keep only children that were introduced by having the `node` in the tree\n      const ids = difference(allChildren, filteredChildren)\n      return ids\n    })\n  }\n  return graph.cache[key]\n}\n\nexport function getEnabledChildEdges(\n  graph: Graph,\n  node: GraphNode\n): Promise<ReadonlyArray<GraphEdgeID>> {\n  const key = `getEnabledChildEdges:${node.id}`\n  if (!graph.cache[key]) {\n    const visited = {}\n    graph.cache[key] = collectEdges(graph, node, {\n      visited,\n      direction: \"children\",\n      filter: isEdgeEnabled,\n    }).then(() => {\n      return Object.keys(visited)\n    })\n  }\n  return graph.cache[key]\n}\n\nexport function getEnabledParentEdges(\n  graph: Graph,\n  node: GraphNode,\n  filter?: (e: GraphEdge) => boolean\n): Promise<ReadonlyArray<GraphEdgeID>> {\n  const key = `getEnabledParentEdges:${node.id}:${getFilterKey(filter)}`\n  if (!graph.cache[key]) {\n    const visited = {}\n    graph.cache[key] = collectEdges(graph, graph.root, {\n      visited,\n      direction: \"children\",\n      filter,\n    }).then(() => {\n      return node.parents\n        .filter((edge) => edge.enabled && edge.id in visited)\n        .map((edge) => edge.id)\n    })\n  }\n  return graph.cache[key]\n}\n\nexport function getAsyncEdges(\n  graph: Graph,\n  node: GraphNode,\n  filter?: (e: GraphEdge) => boolean | typeof LAST_ITEM_IN_BRANCH,\n  {\n    direction = \"children\",\n  }: {\n    direction?: \"children\" | \"parents\"\n  } = {}\n): Promise<ReadonlyArray<GraphEdgeID>> {\n  const key = `getAsyncEdges:${node.id}:${direction}:${getFilterKey(filter)}`\n  if (!graph.cache[key]) {\n    const visited: Record<GraphEdgeID, GraphEdge> = {}\n    graph.cache[key] = collectEdges(graph, node, {\n      visited,\n      direction,\n      filter,\n    }).then(() => {\n      return Object.values(visited)\n        .filter((e) => e.async)\n        .map((e) => e.id)\n    })\n  }\n  return graph.cache[key]\n}\n\nexport function keepOnlyEntryModules(\n  graph: Graph,\n  nodes: ReadonlyArray<GraphNode>\n) {\n  return nodes.filter((node: GraphNode) => {\n    if (node.kind !== \"module\") return false\n    return node.parents.every(\n      (edge) => getNode(graph, edge.fromId).kind !== \"module\"\n    )\n  })\n}\n\nexport function keepOnlyLeafModules(\n  graph: Graph,\n  nodes: ReadonlyArray<GraphNode>\n) {\n  return nodes.filter((node: GraphNode) => {\n    if (node.kind !== \"module\") return false\n    return node.children.length === 0\n  })\n}\n\nexport function isEdgeEnabled(edge: GraphEdge) {\n  return edge.enabled\n}\n","import { getFilterKey } from \"./dependencies\"\nimport type {\n  Graph,\n  GraphEdge,\n  GraphEdgeID,\n  GraphNode,\n  GraphNodeID,\n} from \"./graph\"\nimport { getNode } from \"./graph\"\n\nexport type EdgeChain = GraphNodeID[]\n\nasync function gatherChains(\n  graph: Graph,\n  node: GraphNode,\n  toId: GraphNodeID,\n  path: GraphNodeID[],\n  options: {\n    visited: {\n      [k in GraphEdgeID]: GraphEdge\n    }\n    filter?: (e: GraphEdge) => boolean\n  }\n): Promise<GraphNodeID[][]> {\n  const { filter, visited } = options\n\n  const currentPath = [...path, node.id]\n  if (node.id === toId) return [currentPath]\n\n  const paths = []\n\n  // prefer shortest paths first\n  if (node.children.find((e) => e.toId === toId && (!filter || filter(e)))) {\n    paths.push([...currentPath, toId])\n  }\n\n  for (const edge of node.children) {\n    if (visited[edge.id]) continue\n    if (edge.toId === toId) continue // already included above\n    if (filter && !filter(edge)) continue\n\n    visited[edge.id] = edge\n    const result = await gatherChains(\n      graph,\n      getNode(graph, edge.toId),\n      toId,\n      currentPath,\n      options\n    )\n    if (result.length > 0) {\n      paths.push(...result)\n    }\n    await graph.parallel.yield()\n  }\n  return paths\n}\n\nexport async function findChains(\n  graph: Graph,\n  fromNode: GraphNode,\n  toNode: GraphNode,\n  filter?: (e: GraphEdge) => boolean\n): Promise<EdgeChain[]> {\n  const key = `findChains:${fromNode.id}:${toNode.id}:${getFilterKey(filter)}`\n  if (!graph.cache[key]) {\n    graph.cache[key] = gatherChains(graph, fromNode, toNode.id, [], {\n      visited: {},\n      filter,\n    })\n  }\n  return graph.cache[key]\n}\n","import { EdgeChain } from \"./chains\"\nimport { getFilterKey } from \"./dependencies\"\nimport { getNode, Graph, GraphEdge, GraphNode, GraphNodeID } from \"./graph\"\n\nasync function collectNodeCycles(\n  graph: Graph,\n  node: GraphNode,\n  options: {\n    visited: {\n      [k in GraphNodeID]: GraphNode\n    }\n    branch: GraphNodeID[]\n    cycles: GraphNodeID[][]\n    filter?: (e: GraphEdge) => boolean\n  }\n): Promise<void> {\n  const { visited, filter, cycles } = options\n  const branch = [...options.branch, node.id]\n  visited[node.id] = node\n\n  for (const edge of node.children) {\n    const included = filter ? filter(edge) : true\n    if (!included) continue\n\n    const cycleStart = branch.indexOf(edge.toId)\n    if (cycleStart >= 0) {\n      cycles.push([...branch.slice(cycleStart), edge.toId])\n    } else {\n      if (visited[edge.toId]) continue\n      await collectNodeCycles(graph, getNode(graph, edge.toId), {\n        branch,\n        visited,\n        filter,\n        cycles,\n      })\n    }\n    await graph.parallel.yield()\n  }\n}\n\nexport async function findNodeCycles(\n  graph: Graph,\n  fromNode: GraphNode,\n  filter?: (e: GraphEdge) => boolean\n): Promise<EdgeChain[]> {\n  const key = `findNodeCycles:${fromNode.id}:${getFilterKey(filter)}`\n  if (!graph.cache[key]) {\n    const cycles: GraphNodeID[][] = []\n    graph.cache[key] = collectNodeCycles(graph, fromNode, {\n      branch: [],\n      cycles,\n      visited: {},\n      filter,\n    }).then(() => cycles)\n  }\n  return graph.cache[key]\n}\n","import type { GraphEdge, GraphNode, GraphNodeID } from \"./graph\"\n\nexport type EdgePath = GraphNodeID[]\n\n// https://regex101.com/r/yU5wqf/2\n// 1 - path to packages dir (null if no package)\n// 2 - package name (null if no package)\n// 3 - directory in package\n// 4 - filename\n// 5 - extension\nconst FILENAME_RE =\n  /^(?:(.*\\/(?:node_modules|web_modules|packages|~)\\/)((?:@[^/]+?\\/)?[^/]+))?(.*?\\/)?([^/]+)?(\\.[^./]+)?$/\n\ntype ModuleInfo = {\n  pathToPackage?: string\n  packageName?: string\n  path?: string\n  name?: string\n  extension?: string\n}\n\n// Checks if edge between nodes is local (within the same package)\nexport function isLocalEdge({ name }: GraphEdge): boolean {\n  return name ? name.startsWith(\".\") : false\n}\n\nexport function getModuleInfo({ file, name, id }: GraphNode): ModuleInfo {\n  if (!file) {\n    return { name: name || String(id) || \"(unknown)\" }\n  }\n  const found = file.match(FILENAME_RE)\n  if (!found) {\n    return { path: file }\n  }\n  return {\n    pathToPackage: found[1],\n    packageName: found[2],\n    path: found[3],\n    name: found[4],\n    extension: found[5],\n  }\n}\n\nexport function getPackageName({ file }: GraphNode): string {\n  if (!file) return \"\"\n  const found = file.match(FILENAME_RE)\n  return found ? found[2] : \"\"\n}\n\nexport function getPackageRelativeFilePath(node: GraphNode): string {\n  const { file } = node\n  if (!file) return \"\"\n  const pkg = getPackageName(node)\n  if (!pkg) return \"\"\n  return file.slice(file.indexOf(pkg) + pkg.length + 1)\n}\n\nexport function isExternal({ file }: GraphNode): boolean {\n  if (!file) return false\n  return file.indexOf(\"/node_modules/\") >= 0\n}\n\nexport function getFileExtension({ file }: GraphNode): string {\n  if (!file) return \"\"\n  const dot = file.lastIndexOf(\".\")\n  if (dot <= 0) return \"\"\n  return file.slice(dot + 1)\n}\n\nexport function getSourceLocation(\n  source: string | undefined,\n  location: string | undefined\n): string | undefined {\n  if (!source || !location) return undefined\n  const [rowsLoc, colsLoc] = location.split(\":\")\n  const [rowStart, rowEnd = rowStart + 1]: number[] = rowsLoc\n    .split(\"-\")\n    .map(Number)\n  const [colStart, colEnd = colStart + 1]: number[] = colsLoc\n    .split(\"-\")\n    .map(Number)\n  const lines = source.split(/\\n/g).slice(rowStart - 1, rowEnd - 1)\n  if (lines.length > 1) return lines.join(\"\\n\")\n  if (!lines.length) return undefined\n  return lines[0].slice(colStart, colEnd)\n}\n","import { Remote, wrap } from \"comlink\"\nimport { get, set } from \"idb-keyval\"\nimport md5 from \"md5\"\nimport throat from \"throat\"\nimport { SourceWorkerBackend } from \"./SourceWorkerBackend\"\n\nexport class SourceWorkerClient {\n  private maxWorkers = 4\n  private throttled = throat(this.maxWorkers * 4)\n  private workers: Worker[] = []\n  private backends: Remote<SourceWorkerBackend>[] = []\n  private roundRobinIndex = 0\n\n  private getBackend(index: number) {\n    const workerIndex = index % this.maxWorkers\n    if (!this.backends[workerIndex]) {\n      this.workers[workerIndex] = new Worker(\n        new URL(\"./SourceWorkerBackend\", import.meta.url)\n      )\n      this.backends[workerIndex] = wrap<SourceWorkerBackend>(\n        this.workers[workerIndex]\n      )\n    }\n    return this.backends[workerIndex]\n  }\n\n  release() {\n    this.workers.forEach((worker) => worker && worker.terminate())\n  }\n\n  async getMinifiedSize(source: string, gzip: boolean = true): Promise<number> {\n    // check cache\n    const hash = md5(source)\n    const key = `minifiedSize:v0:${hash}`\n    let sizes = await get(key)\n    if (!sizes) {\n      sizes = await this.throttled(() =>\n        this.getBackend(this.roundRobinIndex++).getMinifiedSizes(source)\n      )\n      await set(key, sizes)\n    }\n    return gzip ? sizes.gzip : sizes.min\n  }\n}\n","import type { Graph } from \"./graph\"\nimport { addEdge, addNode, createGraph, getNode, getNodeId } from \"./graph\"\nimport { getSourceLocation } from \"./info\"\nimport { OpenProgressFn, ParseOptions } from \"./open\"\nimport { SourceWorkerClient } from \"./worker/SourceWorkerClient\"\n\nexport async function readWebpackStats(\n  stats: any,\n  { minifySources = false }: ParseOptions,\n  reportProgress: OpenProgressFn\n): Promise<Graph> {\n  const debug = false\n  const graph = createGraph()\n\n  const includeChunks = false\n  const includeAssets = false\n\n  const { chunks = [], assets = [], modules = [] } = stats\n  const moduleMap = new Map()\n  let index\n\n  // create chunks\n  if (includeChunks) {\n    index = 0\n    for (const chunk of chunks) {\n      if (++index % 1000 === 0)\n        reportProgress(\"creating chunks\", 0.3 + (index / chunks.length) * 0.1)\n      addNode(graph, {\n        id: getNodeId(\"chunk\", chunk.id),\n        originalId: chunk.id,\n        kind:\n          chunk.reason && chunk.reason.indexOf(\"split chunk\")\n            ? \"split-chunk\"\n            : \"chunk\",\n        name: chunk.names[0],\n        size: 0,\n        ...(debug\n          ? {\n              original: chunk,\n            }\n          : null),\n      })\n      // await graph.parallel.yield()\n    }\n  }\n\n  // create assets\n  if (includeAssets) {\n    index = 0\n    for (const asset of assets) {\n      if (++index % 1000 === 0)\n        reportProgress(\"creating assets\", 0.4 + (index / assets.length) * 0.1)\n      addNode(graph, {\n        id: getNodeId(\"asset\", asset.name),\n        originalId: asset.name,\n        kind: \"asset\",\n        name: asset.name,\n        size: asset.size,\n        ...(debug\n          ? {\n              original: asset,\n            }\n          : null),\n      })\n      // await graph.parallel.yield()\n    }\n  }\n\n  index = 0\n  // create modules\n  for (const module of modules) {\n    if (++index % 1000 === 0)\n      reportProgress(\"creating modules\", 0.5 + (index / modules.length) * 0.1)\n    if (module.id == null) {\n      // module has been removed at optimization phase (concatenated, tree-shaken, etc)\n      continue\n    }\n    moduleMap.set(module.identifier, module)\n    const isConcat = module.name.indexOf(\" + \") > 0\n    const isNamespace = module.name.indexOf(\" namespace object\") > 0\n    const kind = isConcat ? \"concat\" : isNamespace ? \"namespace\" : \"module\"\n    addNode(graph, {\n      id: getNodeId(\"module\", module.identifier),\n      originalId: module.id,\n      kind,\n      name: module.name,\n      file: (module.name || \"\").replace(/^.*!| \\+ .+$/, \"\"),\n      size: module.size,\n      exports: Array.isArray(module.providedExports)\n        ? module.providedExports\n        : undefined,\n      usedExports: Array.isArray(module.usedExports)\n        ? module.usedExports\n        : undefined,\n      ...(debug\n        ? {\n            source: module.source,\n            original: module,\n          }\n        : null),\n    })\n    // await graph.parallel.yield()\n  }\n\n  index = 0\n  // create edges\n  for (const module of modules) {\n    if (++index % 1000 === 0)\n      reportProgress(\"creating edges\", 0.6 + (index / modules.length) * 0.1)\n    if (module.id == null) {\n      // module has been removed at optimization phase (concatenated, tree-shaken, etc)\n      continue\n    }\n    const node = getNode(graph, getNodeId(\"module\", module.identifier))\n    if (includeChunks) {\n      for (const chunkId of module.chunks) {\n        addEdge(graph, {\n          fromId: getNodeId(\"chunk\", chunkId),\n          toId: node.id,\n          kind: \"chunk child\",\n          ...(debug\n            ? {\n                original: module,\n              }\n            : null),\n        })\n      }\n    }\n    if (includeAssets) {\n      for (const assetId of module.assets) {\n        addEdge(graph, {\n          fromId: node.id,\n          toId: getNodeId(\"asset\", assetId),\n          kind: \"asset child\",\n          ...(debug\n            ? {\n                original: module,\n              }\n            : null),\n        })\n      }\n    }\n    for (const reason of module.reasons) {\n      const type = reason.type || \"\"\n      const isEntry = type.includes(\"entry\")\n      if (reason.moduleId == null && !isEntry) {\n        // reason has been removed at optimization phase (concatenated, tree-shaken, etc)\n        continue\n      }\n      const fromNode = isEntry\n        ? graph.root\n        : getNode(graph, getNodeId(\"module\", reason.moduleIdentifier))\n      if (fromNode === node) {\n        // we ignore self reference (eg. cjs self exports reference)\n        continue\n      }\n      const fromModule =\n        reason.moduleIdentifier && moduleMap.get(reason.moduleIdentifier)\n      const async =\n        isEntry || (type.includes(\"import()\") && !type.includes(\"eager\"))\n\n      let asyncIds\n      if (async) {\n        asyncIds = module.chunks.flatMap((chunkId: number | string) => {\n          const chunk = chunks.find((ch: any) => ch.id === chunkId)\n          if (!chunk) return []\n          return [chunk.id, ...chunk.names, ...chunk.files]\n        })\n      }\n\n      addEdge(graph, {\n        fromId: fromNode.id,\n        toId: node.id,\n        kind: type,\n        name: isEntry ? node.name : reason.userRequest,\n        async,\n        asyncIds,\n        enabled: !async,\n        fromLoc: reason.loc,\n        fromSource: getSourceLocation(fromModule?.source, reason.loc),\n        ...(debug\n          ? {\n              original: reason,\n            }\n          : null),\n      })\n    }\n    // await graph.parallel.yield()\n  }\n\n  // minify\n  if (minifySources) {\n    const sourceWorker = new SourceWorkerClient()\n    let minifiedModules = 0\n    const promises = []\n    for (const module of modules) {\n      const node = graph.nodes[getNodeId(\"module\", module.identifier)]\n      const source = module.source\n      if (!node || !source) {\n        ++minifiedModules\n        continue\n      }\n      promises.push(\n        sourceWorker\n          .getMinifiedSize(source, minifySources === \"gzip\")\n          // eslint-disable-next-line no-loop-func\n          .then((size) => {\n            node.size = size\n            if (++minifiedModules % 100 === 0) {\n              reportProgress(\n                \"minifying sources\",\n                0.7 + (minifiedModules / modules.length) * 0.2\n              )\n            }\n          })\n      )\n    }\n    await Promise.allSettled(promises)\n    sourceWorker.release()\n  }\n  return graph\n}\n","import { readWebpackStats } from \"./webpack\"\n\nexport type OpenProgressFn = (group: string, progress: number) => void\n\nexport type ParseOptions = {\n  minifySources?: boolean | \"gzip\"\n}\n\nasync function loadJSON(\n  file: string | File,\n  reportProgress: OpenProgressFn\n): Promise<any> {\n  if (typeof file === \"string\") {\n    const result = await fetch(file)\n    reportProgress(\"parsing\", 0.2)\n    return await result.json()\n  } else {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader()\n      reader.onload = () => {\n        reportProgress(\"parsing\", 0.2)\n        const json = JSON.parse(reader.result as any)\n        resolve(json)\n      }\n      reader.onerror = () => {\n        reject(\"Could not read the file\")\n      }\n      reader.readAsBinaryString(file)\n    })\n  }\n}\n\nexport async function openGraph(\n  file: string | File,\n  options: ParseOptions,\n  reportProgress: OpenProgressFn\n) {\n  reportProgress(\"loading\", 0.1)\n  const json = await loadJSON(file, reportProgress)\n\n  const graph = await readWebpackStats(json, options, reportProgress)\n  console.log(\"Graph: \", graph)\n  console.warn(\"Errors found: \", graph.errors)\n\n  return graph\n}\n","import { PaletteColor } from \"@mui/material\"\nimport { AppTheme } from \"../ui/theme\"\nimport { GraphNode } from \"./graph\"\nimport { ConditionalKeys } from \"type-fest\"\n\ntype GroupTestFn = (node: GraphNode) => boolean\n\nexport type GroupInfo = {\n  test: RegExp | GroupTestFn\n  name: string\n  colorName: ConditionalKeys<AppTheme[\"palette\"], PaletteColor>\n  priority: number\n}\ntype GroupsSpec = GroupInfo[]\n\nconst groupsSpec: GroupsSpec = [\n  {\n    test: /\\/node_modules\\//,\n    name: \"Vendors\",\n    colorName: \"groupVendors\",\n    priority: 1,\n  },\n  {\n    test: /\\.(m?jsx?|tsx?)$/,\n    name: \"JS\",\n    colorName: \"groupCode\",\n    priority: 30,\n  },\n  {\n    test: /\\.(css|scss|sass)$/,\n    name: \"CSS\",\n    colorName: \"groupStyles\",\n    priority: 12,\n  },\n  {\n    test: /\\.(jpe?g|png|gif|webm)$/,\n    name: \"Images\",\n    colorName: \"groupImages\",\n    priority: 11,\n  },\n  {\n    test: /\\.(graphql)$/,\n    name: \"GraphQL\",\n    colorName: \"groupOther\",\n    priority: 10,\n  },\n  {\n    test: /.*/,\n    name: \"Other\",\n    colorName: \"groupOther\",\n    priority: 5,\n  },\n]\n\nexport function getNodeGroup(node: GraphNode): GroupInfo {\n  for (const group of groupsSpec) {\n    if (typeof group.test === \"function\" && !group.test(node)) continue\n    if (\n      group.test instanceof RegExp &&\n      !group.test.test(node.file || \"<unknown>\")\n    )\n      continue\n    return group\n  }\n  throw new Error(`No group matched node ${node.id}`)\n}\n","import { GraphEdge } from \"./graph\"\nimport { LAST_ITEM_IN_BRANCH } from \"./dependencies\"\n\nexport function currentGraphFilter(edge: GraphEdge) {\n  return edge.enabled\n}\n\nexport function baseGraphFilter(edge: GraphEdge) {\n  return !edge.async || edge.enabled\n}\n\nexport function stopOnAsyncModulesFilter(edge: GraphEdge) {\n  return edge.async ? LAST_ITEM_IN_BRANCH : true\n}\n\nexport function allAsyncAndEnabledFilter(edge: GraphEdge) {\n  return edge.async || edge.enabled\n}\n","import { transferHandlers } from \"comlink\"\nimport { findKey, memoize } from \"lodash\"\nimport * as filters from \"../filters\"\n\nconst knownFilters = Object.values(filters).filter(\n  (f) => typeof f === \"function\"\n)\n\nexport const registerTransferHandlers = memoize(() => {\n  transferHandlers.set(\"FILTER\", {\n    canHandle: (v: any): v is Function => knownFilters.includes(v),\n    serialize: (filter) => [findKey(filters, (f) => filter === f), []],\n    deserialize: (name: any) =>\n      // @ts-expect-error\n      filters[name],\n  })\n})\n","import { expose } from \"comlink\"\nimport { omit } from \"lodash\"\nimport { findChains } from \"../chains\"\nimport { applyChanges, Changes, revertGraph } from \"../changes\"\nimport { findNodeCycles } from \"../cycles\"\nimport {\n  getAsyncEdges,\n  getDeepNodeChildren,\n  getDeepNodeParents,\n  getEnabledChildEdges,\n  getEnabledParentEdges,\n  getNodesRetainedByEdge,\n  getNodesRetainedByNode,\n} from \"../dependencies\"\nimport { Graph, modifyGraph } from \"../graph\"\nimport { openGraph, OpenProgressFn, ParseOptions } from \"../open\"\nimport { createParallelProcessor } from \"../parallel\"\nimport {\n  calculateGroupSizes,\n  calculateTreeSizeRetainedByNode,\n  calculateTreeSize,\n  calculateTreeSizeRetainedByEdge,\n} from \"../size\"\nimport { registerTransferHandlers } from \"./transferHandlers\"\n\ntype TransferableGraph = Omit<Graph, \"cache\" | \"revert\" | \"parallel\">\n\n// @ts-expect-error\nlet graph: Graph = module.hot?.data?.graph\n\nfunction bindGraph<Args extends Array<any>, Ret>(\n  fn: (graph: Graph, ...args: Args) => Ret\n): (...args: Args) => Ret {\n  return (...args) => {\n    if (!graph) throw new Error(\"Graph is not set on worker!\")\n    return fn(graph, ...args)\n  }\n}\n\nconst backend = {\n  async openGraph(\n    file: string | File,\n    options: ParseOptions,\n    reportProgress: OpenProgressFn\n  ): Promise<TransferableGraph> {\n    registerTransferHandlers()\n    if (graph) {\n      graph.parallel.abort(`Worker Abort v${graph.version}`)\n    }\n    graph = await openGraph(file, options, reportProgress)\n    return omit(graph, [\"cache\", \"revert\", \"parallel\"])\n  },\n\n  async setGraph(newGraph: TransferableGraph) {\n    registerTransferHandlers()\n    if (graph) {\n      graph.parallel.abort(`Worker Abort v${graph.version}`)\n    }\n    console.log(\"[worker] setting graph\")\n    graph = {\n      ...newGraph,\n      cache: {},\n      errors: [],\n      revert: [],\n      parallel: createParallelProcessor({ maxDelay: 100 }),\n    }\n  },\n\n  async applyChanges(changes: Changes) {\n    await modifyGraph(graph, (newGraph) => {\n      revertGraph(newGraph)\n      applyChanges(newGraph, changes)\n      graph = newGraph\n    })\n  },\n\n  calculateGroupSizes: bindGraph(calculateGroupSizes),\n  calculateTreeSizeRetainedByNode: bindGraph(calculateTreeSizeRetainedByNode),\n  calculateTreeSizeRetainedByEdge: bindGraph(calculateTreeSizeRetainedByEdge),\n  calculateTreeSize: bindGraph(calculateTreeSize),\n  findChains: bindGraph(findChains),\n  findNodeCycles: bindGraph(findNodeCycles),\n  getAsyncEdges: bindGraph(getAsyncEdges),\n  getDeepNodeChildren: bindGraph(getDeepNodeChildren),\n  getEnabledChildEdges: bindGraph(getEnabledChildEdges),\n  getEnabledParentEdges: bindGraph(getEnabledParentEdges),\n  getNodesRetainedByNode: bindGraph(getNodesRetainedByNode),\n  getNodesRetainedByEdge: bindGraph(getNodesRetainedByEdge),\n  getDeepNodeParents: bindGraph(getDeepNodeParents),\n}\n\nexport type GraphWorkerBackend = typeof backend\n\nexport { backend as localBackend }\n\nexpose(backend)\n\nif (\"hot\" in module) {\n  // @ts-expect-error\n  module.hot.dispose((data) => {\n    data.graph = graph\n  })\n  // @ts-expect-error\n  module.hot.accept()\n}\n","import { omit, omitBy } from \"lodash\"\nimport { Graph, GraphEdge, GraphEdgeID, resolveEdge, toggleEdge } from \"./graph\"\n\nexport type Changes = {\n  edgeToggles?: Record<GraphEdgeID, boolean>\n}\n\nexport const MOCKED_EDGE_KIND = \"mocked\"\n\nexport function hasChanges(changes: Changes): boolean {\n  return (\n    (changes.edgeToggles && Object.values(changes.edgeToggles).length > 0) ||\n    false\n  )\n}\n\nexport function countVisibleChanges(changes: Changes): number {\n  return changes.edgeToggles\n    ? Object.values(changes.edgeToggles).reduce(\n        (sum, enabled) => sum + (enabled ? 0 : 1),\n        0\n      )\n    : 0\n}\n\nexport function addEdgeToggleChange(\n  graph: Graph,\n  changes: Changes,\n  edge: GraphEdge,\n  enabled: boolean\n): Changes {\n  const wasOriginallyEnabled = edge\n    ? edge.kind !== MOCKED_EDGE_KIND && !edge.async\n    : false\n  // Add to queue only if it's a different state than originally\n  if (enabled !== wasOriginallyEnabled) {\n    return {\n      ...changes,\n      edgeToggles: { ...changes.edgeToggles, [edge.id]: enabled },\n    }\n  }\n  if (changes.edgeToggles && changes.edgeToggles[edge.id] != null) {\n    return { ...changes, edgeToggles: omit(changes.edgeToggles, [edge.id]) }\n  }\n  return changes\n}\n\nexport function resetEdgeToggles(changes: Changes, async: boolean): Changes {\n  return {\n    // async edges are enabled, sync edges are disabled - so we can just remove either one or the other\n    edgeToggles: omitBy(\n      changes.edgeToggles || {},\n      (enabled) => enabled === async\n    ),\n  }\n}\n\nexport function revertGraph(graph: Graph) {\n  for (const revert of graph.revert.reverse()) {\n    revert()\n  }\n  graph.revert.splice(0)\n}\n\nexport function applyChanges(graph: Graph, changes: Changes) {\n  for (const [edgeId, enabled] of Object.entries(changes.edgeToggles || {})) {\n    const edge = resolveEdge(graph, edgeId)\n    if (!edge) {\n      graph.errors.push({\n        message: `Edge ${edgeId} doesnt exist`,\n      })\n      continue\n    }\n    const prevEnabled = edge.enabled\n    graph.revert.push(() => {\n      toggleEdge(graph, edge, prevEnabled)\n    })\n    toggleEdge(graph, edge, enabled)\n  }\n}\n","import {\n  getDeepNodeChildren,\n  getFilterKey,\n  getNodesRetainedByEdge,\n  getNodesRetainedByNode,\n} from \"./dependencies\"\nimport type { Graph, GraphEdge, GraphNode, GraphNodeID } from \"./graph\"\nimport { getNode } from \"./graph\"\nimport { getNodeGroup, GroupInfo } from \"./groups\"\n\nexport type EdgePath = GraphNodeID[]\n\nexport function calculateTreeSize(\n  graph: Graph,\n  node: GraphNode,\n  filter?: (e: GraphEdge) => boolean\n): Promise<number> {\n  const key = `calculateTreeSize:${node.id}:${getFilterKey(filter)}`\n\n  if (!graph.cache[key]) {\n    graph.cache[key] = getDeepNodeChildren(graph, node, filter).then((tree) =>\n      tree.reduce((sum, id) => sum + getNode(graph, id).size, node.size)\n    )\n  }\n  return graph.cache[key]\n}\n\nexport function calculateTreeSizeRetainedByNode(\n  graph: Graph,\n  rootNode: GraphNode,\n  node: GraphNode,\n  filter?: (e: GraphEdge) => boolean\n): Promise<number | null> {\n  const key = `calculateTreeSizeRetainedByNode:${rootNode.id}:${\n    node.id\n  }:${getFilterKey(filter)}`\n\n  if (!graph.cache[key]) {\n    graph.cache[key] = getNodesRetainedByNode(\n      graph,\n      rootNode,\n      node,\n      filter\n    ).then((tree) =>\n      tree.length > 0\n        ? tree.reduce((sum, id) => sum + getNode(graph, id).size, 0)\n        : null\n    )\n  }\n  return graph.cache[key]\n}\n\nexport function calculateTreeSizeRetainedByEdge(\n  graph: Graph,\n  rootNode: GraphNode,\n  edge: GraphEdge,\n  filter?: (e: GraphEdge) => boolean\n): Promise<number> {\n  const key = `calculateTreeSizeRetainedByEdge:${rootNode.id}:${\n    edge.id\n  }:${getFilterKey(filter)}`\n\n  if (!graph.cache[key]) {\n    graph.cache[key] = getNodesRetainedByEdge(\n      graph,\n      rootNode,\n      edge,\n      filter\n    ).then((tree) => tree.reduce((sum, id) => sum + getNode(graph, id).size, 0))\n  }\n  return graph.cache[key]\n}\n\nexport type GroupSizeInfo = {\n  group: GroupInfo\n  size: number\n  count: number\n}\nexport function calculateGroupSizes(\n  graph: Graph,\n  rootNode: GraphNode | undefined,\n  node: GraphNode,\n  filter?: (e: GraphEdge) => boolean\n): Promise<GroupSizeInfo[]> {\n  const key = `calculateGroupSizes:${rootNode?.id}:${node.id}:${getFilterKey(\n    filter\n  )}`\n\n  if (!graph.cache[key]) {\n    const promise =\n      !rootNode || rootNode === node\n        ? getDeepNodeChildren(graph, node, filter)\n        : getNodesRetainedByNode(graph, rootNode, node, filter)\n    graph.cache[key] = promise.then((tree) => {\n      const infos = new Map<GroupInfo, GroupSizeInfo>()\n      if (!tree.includes(node.id)) tree = [node.id, ...tree]\n      tree.forEach((id) => {\n        const node = getNode(graph, id)\n        const group = getNodeGroup(node)\n        let info = infos.get(group)\n        if (!info) {\n          info = { group, count: 0, size: 0 }\n          infos.set(group, info)\n        }\n        info.count += 1\n        info.size += node.size\n      })\n      return Array.from(infos.values()).sort(\n        (a, b) => b.group.priority - a.group.priority\n      )\n    })\n  }\n  return graph.cache[key]\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [763,886], () => (__webpack_require__(6647)))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + {\"272\":\"10d56604\",\"763\":\"bd7cd801\",\"886\":\"957899b7\"}[chunkId] + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = (chunkId) => {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.hmd = (module) => {\n\tmodule = Object.create(module);\n\tif (!module.children) module.children = [];\n\tObject.defineProperty(module, 'exports', {\n\t\tenumerable: true,\n\t\tset: () => {\n\t\t\tthrow new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);\n\t\t}\n\t});\n\treturn module;\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","__webpack_require__.p = \"/webpack-chopshop/\";","__webpack_require__.b = self.location + \"/../../../\";\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t647: 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = globalThis[\"webpackChunkwebpack_chopshop\"] = globalThis[\"webpackChunkwebpack_chopshop\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn Promise.all([\n\t\t__webpack_require__.e(763),\n\t\t__webpack_require__.e(886)\n\t]).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["AbortSignal","constructor","message","this","toString","ABORTED","createParallelProcessor","maxDelay","window","abortSignalReject","aborted","abortSignal","Promise","_","reject","lastYield","performance","now","yield","resolve","catch","err","setTimeout","abort","ROOT_NODE_ID","createNode","_node","parents","children","getNodeId","kind","id","getEdgeId","from","to","getNode","graph","node","nodes","Error","resolveEdge","edges","addNode","addEdge","_edge","fromId","toId","edge","enabled","push","toggleEdge","filterKeys","WeakMap","filterKeysCounter","getFilterKey","f","has","set","name","get","LAST_ITEM_IN_BRANCH","async","collectNodes","options","direction","visited","filter","included","parallel","collectEdges","getDeepNodeChildren","key","cache","then","Object","keys","getNodesRetainedByNode","rootNode","allChildrenPromise","filteredChildrenPromise","all","allChildren","filteredChildren","indexOf","ids","difference","includes","getNodesRetainedByEdge","e","isEdgeEnabled","gatherChains","path","currentPath","paths","find","result","length","collectNodeCycles","cycles","branch","cycleStart","slice","getSourceLocation","source","location","rowsLoc","colsLoc","split","rowStart","rowEnd","map","Number","colStart","colEnd","lines","join","SourceWorkerClient","maxWorkers","throttled","throat","workers","backends","roundRobinIndex","getBackend","index","workerIndex","Worker","URL","wrap","release","forEach","worker","terminate","gzip","md5","sizes","getMinifiedSizes","min","readWebpackStats","stats","minifySources","reportProgress","root","originalId","size","version","errors","revert","createGraph","chunks","assets","modules","moduleMap","Map","module","identifier","isConcat","isNamespace","file","replace","exports","Array","isArray","providedExports","undefined","usedExports","reason","reasons","type","isEntry","moduleId","fromNode","moduleIdentifier","fromModule","asyncIds","flatMap","chunkId","chunk","ch","names","files","userRequest","fromLoc","loc","fromSource","sourceWorker","minifiedModules","promises","getMinifiedSize","allSettled","openGraph","json","fetch","reader","FileReader","onload","JSON","parse","onerror","readAsBinaryString","loadJSON","console","log","warn","groupsSpec","test","colorName","priority","currentGraphFilter","baseGraphFilter","stopOnAsyncModulesFilter","allAsyncAndEnabledFilter","knownFilters","values","filters","registerTransferHandlers","memoize","transferHandlers","canHandle","v","serialize","findKey","deserialize","hot","data","bindGraph","fn","args","backend","omit","newGraph","changes","modifyGraph","reverse","splice","revertGraph","edgeId","entries","edgeToggles","prevEnabled","applyChanges","calculateGroupSizes","promise","tree","infos","group","RegExp","getNodeGroup","info","count","sort","a","b","calculateTreeSizeRetainedByNode","reduce","sum","calculateTreeSizeRetainedByEdge","calculateTreeSize","findChains","toNode","findNodeCycles","getAsyncEdges","getEnabledChildEdges","getEnabledParentEdges","getDeepNodeParents","expose","dispose","accept","__webpack_module_cache__","__webpack_require__","cachedModule","loaded","__webpack_modules__","call","m","x","__webpack_exports__","O","deferred","chunkIds","notFulfilled","Infinity","i","fulfilled","j","every","r","n","getter","__esModule","d","definition","o","defineProperty","enumerable","u","miniCssF","g","globalThis","Function","hmd","create","obj","prop","prototype","hasOwnProperty","Symbol","toStringTag","value","nmd","p","self","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","pop","next"],"sourceRoot":""}